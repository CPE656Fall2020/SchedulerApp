# Scheduler Database Overview

## Database Design
Our database is a SQLite Database, managed through Microsoft Entity Framework Core. EF Core is an Object-Relational-Mapper framework, or ORM, which provides nearly-seamless translation between raw SQL entries and objects in code. This allows for in-code manipulation of objects in familiar structures, like lists, and with standard algorithms and components, while providing automatic SQL change tracking, querying, and committing functionality behind the scenes.

``SchedulerContext`` is the top-level services used with Entity Framework, and exposes all data in the database to the application.

``SchedulerSummarizer`` forms our Data Abstraction Layer. This component handles reading raw experimental entries from the database, grouping them into related test buckets, and providing computed data that accurately describes an available platform based on all relevant experimental data. Summarized data is used throughout the scheduling application to compute effective power usage.

## Models
Two main types of data are stored in the database: encryption profiles and compression profiles. Each one of these has a dedicated POCO (Plain Old CLR Object - aka a class that contains just properties and variables and can be trivially serialized) in the **SchedulerDatabase** `\Models\*` folder. 

## Database Layout
As previously mentioned, we are using SQLite as the underlying database engine. Entity Framework Core is highly modular and configurable to be interoperable among a variety of relational databases, such as MS SQL Server, Oracle SQL, and SQLite. However, SQLite was chosen due to its lightweight, in-process operation model. Being in-process, SQLite does not require any heavy database engine to be installed on the target computer, as all database components are distributed as dlls with EF Core and loaded in-memory at runtime. SQLite is also an industry standard tool with official support from Microsoft, and a reputation for being compact, lightweight, and easy to use.

We are using the "Code-First" database approach. In Code-First, the POCO models and `DbContext` are arranged first in code, and then the database schema is automatically generated by EF Core at startup. This provides the most convenient way to setup a database, as we have no requirement for the schema to match any existing database layout. The Fluent layout API is used for annotating certain aspects of our models to guide EF Core in schema generation.

## Migration
Since the Code-First approach is used, full Migration support is available. Migrations allow for upgrading databases (non-destructively) to include new fields. Entity Framework uses a hidden table to track the version number of a database, and any DB loaded by the scheduling application will be automatically upgraded to the latest supported format if required. 

The `\Migrations\*` folder provides the automatically-generated schema-upgrade files used by Entity Framework for the various iterations of the database that have been developed. The Entity Framework Design Tools are used to generation migrations through the Visual Studio Package Manager Console. For more information about how to modify the DB Models and perform an automatic migration, consult [the docs from Microsoft on MSDN](https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=vs.)